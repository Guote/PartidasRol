import "../../../../svelte/src/internal/disclose-version.js";
import { child } from "../../../../svelte/src/internal/client/dom/operations.js";
import { legacy_pre_effect, legacy_pre_effect_reset, template_effect } from "../../../../svelte/src/internal/client/reactivity/effects.js";
import { mutable_state, set, mutate } from "../../../../svelte/src/internal/client/reactivity/sources.js";
import { push, pop, get, safe_get, deep_read_state } from "../../../../svelte/src/internal/client/runtime.js";
import { append, template } from "../../../../svelte/src/internal/client/dom/template.js";
import { if_block } from "../../../../svelte/src/internal/client/dom/blocks/if.js";
import { set_attribute } from "../../../../svelte/src/internal/client/dom/elements/attributes.js";
import { set_class } from "../../../../svelte/src/internal/client/dom/elements/class.js";
import { bind_this } from "../../../../svelte/src/internal/client/dom/elements/bindings/this.js";
import { init } from "../../../../svelte/src/internal/client/dom/legacy/lifecycle.js";
import { prop } from "../../../../svelte/src/internal/client/reactivity/props.js";
import { createEventDispatcher, onMount, onDestroy } from "../../../../svelte/src/index-client.js";
import { bindHandlers } from "./Utils.js";
const uuid = (prefix) => {
  return prefix + "_" + Math.floor(Math.random() * 1e9) + String(Date.now());
};
const createScriptLoader = () => {
  let state = {
    listeners: [],
    scriptId: uuid("tiny-script"),
    scriptLoaded: false,
    injected: false
  };
  const injectScript = (scriptId, doc, url, cb) => {
    state.injected = true;
    const script = doc.createElement("script");
    script.referrerPolicy = "origin";
    script.type = "application/javascript";
    script.src = url;
    script.onload = () => {
      cb();
    };
    if (doc.head) doc.head.appendChild(script);
  };
  const load = (doc, url, callback) => {
    if (state.scriptLoaded) {
      callback();
    } else {
      state.listeners.push(callback);
      if (!state.injected) {
        injectScript(state.scriptId, doc, url, () => {
          state.listeners.forEach((fn) => fn());
          state.scriptLoaded = true;
        });
      }
    }
  };
  return { load };
};
let scriptLoader = createScriptLoader();
var root_1 = template(`<div></div>`);
var root_2 = template(`<textarea style="visibility:hidden"></textarea>`);
var root = template(`<div><!></div>`);
function Editor($$anchor, $$props) {
  push($$props, false);
  var _a = mutable_state();
  let id = prop($$props, "id", 24, () => uuid("tinymce-svelte"));
  let inline = prop($$props, "inline", 8, void 0);
  let disabled = prop($$props, "disabled", 8, false);
  let apiKey = prop($$props, "apiKey", 8, "no-api-key");
  let channel = prop($$props, "channel", 8, "6");
  let scriptSrc = prop($$props, "scriptSrc", 8, void 0);
  let conf = prop($$props, "conf", 24, () => ({}));
  let modelEvents = prop($$props, "modelEvents", 8, "change input undo redo");
  let value = prop($$props, "value", 12, "");
  let text = prop($$props, "text", 12, "");
  let cssClass = prop($$props, "cssClass", 8, "tinymce-wrapper");
  let container = mutable_state();
  let element = mutable_state();
  let editorRef = mutable_state();
  let lastVal = mutable_state(value());
  let disablindCache = mutable_state(disabled());
  const dispatch = createEventDispatcher();
  const getTinymce = () => {
    const getSink = () => {
      return typeof window !== "undefined" ? window : global;
    };
    const sink = getSink();
    return sink && sink.tinymce ? sink.tinymce : null;
  };
  const init$1 = () => {
    const finalInit = Object.assign(Object.assign({}, conf()), {
      target: get(element),
      inline: inline() !== void 0 ? inline() : conf().inline !== void 0 ? conf().inline : false,
      readonly: disabled(),
      setup: (editor) => {
        set(editorRef, editor);
        editor.on("init", () => {
          editor.setContent(value());
          editor.on(modelEvents(), () => {
            set(lastVal, editor.getContent());
            if (get(lastVal) !== value()) {
              value(get(lastVal));
              text(editor.getContent({ format: "text" }));
            }
          });
        });
        bindHandlers(editor, dispatch);
        if (typeof conf().setup === "function") {
          conf().setup(editor);
        }
      }
    });
    mutate(element, get(element).style.visibility = "");
    void getTinymce().init(finalInit);
  };
  onMount(() => {
    if (getTinymce() !== null) {
      init$1();
    } else {
      const script = scriptSrc() ? scriptSrc() : `https://cdn.tiny.cloud/1/${apiKey()}/tinymce/${channel()}/tinymce.min.js`;
      scriptLoader.load(get(container).ownerDocument, script, () => {
        init$1();
      });
    }
  });
  onDestroy(() => {
    var _a2;
    if (get(editorRef)) {
      (_a2 = getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(get(editorRef));
    }
  });
  legacy_pre_effect(
    () => (get(editorRef), get(lastVal), deep_read_state(value()), deep_read_state(disabled()), get(disablindCache), safe_get(_a)),
    () => {
      if (get(editorRef) && get(lastVal) !== value()) {
        get(editorRef).setContent(value());
        text(get(editorRef).getContent({ format: "text" }));
      }
      if (get(editorRef) && disabled() !== get(disablindCache)) {
        set(disablindCache, disabled());
        if (typeof (set(_a, get(editorRef).mode) === null || safe_get(_a) === void 0 ? void 0 : safe_get(_a).set) === "function") {
          get(editorRef).mode.set(disabled() ? "readonly" : "design");
        } else {
          get(editorRef).setMode(disabled() ? "readonly" : "design");
        }
      }
    }
  );
  legacy_pre_effect_reset();
  init();
  var div = root();
  bind_this(div, ($$value) => set(container, $$value), () => get(container));
  var node = child(div);
  if_block(
    node,
    inline,
    ($$anchor2) => {
      var div_1 = root_1();
      bind_this(div_1, ($$value) => set(element, $$value), () => get(element));
      template_effect(() => set_attribute(div_1, "id", id()));
      append($$anchor2, div_1);
    },
    ($$anchor2) => {
      var textarea = root_2();
      bind_this(textarea, ($$value) => set(element, $$value), () => get(element));
      template_effect(() => set_attribute(textarea, "id", id()));
      append($$anchor2, textarea);
    }
  );
  template_effect(() => set_class(div, cssClass()));
  append($$anchor, div);
  pop();
}
export {
  Editor as default
};
