import { is_promise } from "../../../shared/utils.js";
import { is_runes, set_active_effect, set_active_reaction, set_component_context, flush_sync, component_context } from "../../runtime.js";
import { block, resume_effect, branch, pause_effect } from "../../reactivity/effects.js";
import { queue_micro_task } from "../task.js";
import { set, source, mutable_source } from "../../reactivity/sources.js";
const PENDING = 0;
const THEN = 1;
const CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  var anchor = node;
  var runes = is_runes();
  var active_component_context = component_context;
  var input;
  var pending_effect;
  var then_effect;
  var catch_effect;
  var input_source = (runes ? source : mutable_source)(
    /** @type {V} */
    void 0
  );
  var error_source = (runes ? source : mutable_source)(void 0);
  var resolved = false;
  function update(state, restore) {
    resolved = true;
    if (restore) {
      set_active_effect(effect);
      set_active_reaction(effect);
      set_component_context(active_component_context);
    }
    if (state === PENDING && pending_fn) {
      if (pending_effect) resume_effect(pending_effect);
      else pending_effect = branch(() => pending_fn(anchor));
    }
    if (state === THEN && then_fn) {
      if (then_effect) resume_effect(then_effect);
      else then_effect = branch(() => then_fn(anchor, input_source));
    }
    if (state === CATCH && catch_fn) {
      if (catch_effect) resume_effect(catch_effect);
      else catch_effect = branch(() => catch_fn(anchor, error_source));
    }
    if (state !== PENDING && pending_effect) {
      pause_effect(pending_effect, () => pending_effect = null);
    }
    if (state !== THEN && then_effect) {
      pause_effect(then_effect, () => then_effect = null);
    }
    if (state !== CATCH && catch_effect) {
      pause_effect(catch_effect, () => catch_effect = null);
    }
    if (restore) {
      set_component_context(null);
      set_active_reaction(null);
      set_active_effect(null);
      flush_sync();
    }
  }
  var effect = block(() => {
    if (input === (input = get_input())) return;
    if (is_promise(input)) {
      var promise = input;
      resolved = false;
      promise.then(
        (value) => {
          if (promise !== input) return;
          set(input_source, value);
          update(THEN, true);
        },
        (error) => {
          if (promise !== input) return;
          set(error_source, error);
          update(CATCH, true);
        }
      );
      {
        queue_micro_task(() => {
          if (!resolved) update(PENDING, true);
        });
      }
    } else {
      set(input_source, input);
      update(THEN, false);
    }
    return () => input = null;
  });
}
export {
  await_block
};
